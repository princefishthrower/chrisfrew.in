---
title: "Lesson 1: The ABCs of React Hooks"
description: "React Hooks are like alphabet soup - it's easy as A, B, C!"
date: "2021-12-22"
tags: Clean React TypeScript Hooks,React Hooks,Learning Series
cleanReactTypeScriptHooksOrder: 1
---

import { Link } from 'gatsby'

<i>
    Note: this is part of a larger series, "Clean React TypeScript Hooks". If
    you're interested, check out{" "}
    <Link to="/blog/series/clean-react-typescript-hooks">the series overview</Link>.
</i>

Blog readers, it's come to my attention that far too many devs get mucked down in new languages, syntax, tools, and endless engineering debates while skipping a critical lesson: _learning the very basic concepts_. So here is my remedy (or attempt) at correct that problem, at least for React hooks. Through a handful of lessons, I'm going to teach you how to write super clean, super cool React Hooks using TypeScript. But again, we're going to start with the basics, and you can't get much more basic than the ABC's. 

So here's where we'll start: Describing all the React Hooks using the ABC's.

## What's A React Hook?

Before getting to the ABC's of React Hooks, I probably should first define what a React Hook is:

I'll do my version first:

> a React Hook is a function that takes input and returns output

And for completeness, React's official description:

> Hooks let you use state and other React features without writing a class.

(and yes, the official documentation capitalizes the 'H' in 'Hooks', so I'll be following their lead.)

That's it.

Seems too simple right? I'll prove it, explaining each React Hook with our beloved ABC's.

## useState In ABC's:

> Give me a value A and setter function B, where I want my initial value of A to be C

```tsx
const [A, B] = useState(C)
```

## useEffect In In ABC's:

> Run function D when E changes

```tsx
useEffect(() => {
   D()
}, [E]
```

but we of course note `useEffect()` seems to have an array for the "when E changes" part, so let's imagine we have also a value `F` we want to detect changes in. Well, simply add this to the change array:

> Run function D when E or F changes

```tsx
useEffect(() => {
   D()
}, [E, F]
```

Want to run function `D` when _nothing_ changes? That's fine too, just empty out your dependency array. The change here is then implicit, in that it will only fire once, when the hook mounts. This is the equivalent of the (now infamous) `componentDidMount`:

> Run function D on mount

```tsx
useEffect(() => {
    D()
}, []
```

So, you may be asking, well if there is a hook equivalent for `componentDidMount`, there certainly should be one for `componentWillUnmount`, right? Yep! This is done by using `return` in `useEffect`. Let's add more letters to our alphabet, this time a function `G`:

> Run function G on unmount

```tsx
useEffect(() => {
    return G()
}, []
```