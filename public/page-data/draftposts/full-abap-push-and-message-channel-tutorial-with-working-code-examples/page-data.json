{"componentChunkName":"component---src-templates-blog-post-js","path":"/draftposts/full-abap-push-and-message-channel-tutorial-with-working-code-examples/","result":{"data":{"site":{"siteMetadata":{"title":"Chris' Full Stack Blog"}},"markdownRemark":{"id":"f3cb3feb-ddd4-53fb-a2d3-410fd77095c7","excerpt":"Add some spice to your SAPUI5 apps! (Or even normal webapps, for that matter) In short, I was a noob.  I once wrote a SAPUI5 app that would display a stream‚Ä¶","html":"<h1>Add some spice to your SAPUI5 apps!</h1>\n<h2>(Or even normal webapps, for that matter)</h2>\n<p>In short, I was a noob. </p>\n<p>I once wrote a SAPUI5 app that would display a stream warehouse task code from a warehouse in realtime. How did I do it?</p>\n<p>I wrote a <code class=\"language-text\">window.setInterval()</code> function that would ping table <code class=\"language-text\">/SCWM/WT</code>  and check for any new lines - with an OData <code class=\"language-text\">GET_ENTITY_SET</code> server request. üòÖ üòÖ üòÖ</p>\n<p>Yeah.</p>\n<p>Although this may initially sound fine - and indeed, it <em>did</em> work - it‚Äôs not an optimal solution for a few reasons, listed here in terms of level of inefficiency:</p>\n<ol>\n<li>The database is constantly queried, which can potentially slow down DB transactions if the app was run at scale or if the <code class=\"language-text\">setInterval()</code> interval was decreased to run more often.</li>\n<li>There is a lot of load on the frontend in terms of input/output traffic - I first have to send a request to the server (which we will see goes away with websockets), and then in the response there can be a relatively large JSON array sent to the frontend if within the last interval if a large amount of warehouse tasks were created in that interval.</li>\n<li>The query method is simply a bad user experience! Imagine, you won‚Äôt be seeing the warehouse tasks in real time - only the new ones appearing in batches that have been created within the interval of whatever that <code class=\"language-text\">setInterval()</code> function is set to. (It‚Äôs 2020, UI/UX is king üëë right?)</li>\n</ol>\n<h2>Websockets to the Rescue</h2>\n<p>I was informed of the concept of websockets from one of our consultants. Then I was even luckier to learn a bit more about the technical aspects (when to subscribe, unsubscribe, destroy, and create websockets instances from actions on the front end).</p>\n<p>So here‚Äôs how to add websockets to your SAPUI5 or OpenUI5 app<sup><a href=\"#footnote-1\">1</a></sup>.</p>\n<h2>SAP Transactions Needed</h2>\n<p>All backend push and messaging channels can be managed with just two transactions: <code class=\"language-text\">SAMC</code>, for message channels and <code class=\"language-text\">SAPC</code>, for push channels. Easy enough.</p>\n<h2>Creating a Message Channel</h2>\n<p>As we will see, to create a proper push channel, we will first need a message channel, so that is where we start off. An ABAP message channel is a way of publishing information from any programs to any push channel. The best thing about push channels is that if the push channel <em>isn‚Äôt</em> listening, there is no error and nothing else negative happens anywhere else in the system - that is, granted you <code class=\"language-text\">TRY</code> and <code class=\"language-text\">CATCH</code> your push channel messaging properly.</p>\n<p>So let‚Äôs get started in transaction <code class=\"language-text\">SAMC</code>. Right click the ABAP Messaging Channels Node and select create:</p>\n<p><img src=\"\"></p>\n<p>Give your channel a name, pick your development package, and then a window comes up on the right:</p>\n<p><img src=\"\"></p>\n<p>We define the message channel name, description, channel ID, and, most importantly, define what programs can use this message channel and what type of message this channel will handle (there are only 3 options - <code class=\"language-text\">BINARY</code>, <code class=\"language-text\">PCP</code>, and <code class=\"language-text\">TEXT</code>). Since we‚Äôll be using JSON, we want <code class=\"language-text\">TEXT</code>. Activate your message channel. So far so good.</p>\n<h2>Creating a Push Channel</h2>\n<p>Ok, now we head to transaction <code class=\"language-text\">SAPC</code> - we are now going to define a websocket that will be hooked up to our push channel. That way, when something happens in our program, it will message to all subscribed channels, which will be forwarded , and then ultimately, to the most important part, the frontend for our user to see! </p>\n<p>In the same method as in <code class=\"language-text\">SAMC</code> with our push channel, we right click ‚ÄòABAP Push Channels‚Äô and select create. After providing a name and development packet, the window that appears on the right is a bit simpler than that of the message channel - you should only need to provide the description. The ‚ÄòConnection Type‚Äô should already be set to WebSocket and the class name and service path should already be generated based on the name you provided for the class. It‚Äôs important to take note of that service path - we‚Äôll need it for our SAPUI5 / OpenUI5 WebSocket JavaScript implementation. Before activating, first click the ‚ÄòGenerate Class and Service‚Äô button. You should only need to do it once, and then the button will be greyed out. Don‚Äôt worry if there is message that comes from activation of the class about the non-implemented method <code class=\"language-text\">on_message</code>. That‚Äôs what were about to implement!</p>\n<p>So Hop into your editor of choice, and open up the class that was generated. (Alternatively you can double click the method right away in <code class=\"language-text\">SAMC</code>.)</p>\n<p>We can see that the class SAP generated for us inherits from <code class=\"language-text\">CL_APC_WSP_EXT_STATELESS_BASE</code> which in turn implements. So, at the <em>bare minmum</em>, we have to implement the two methods <code class=\"language-text\">ON_MESSAGE</code> and <code class=\"language-text\">ON_START</code>. But we can also implement the other three methods <code class=\"language-text\">ON_ACCEPT</code>, <code class=\"language-text\">ON_CLOSE</code>, and <code class=\"language-text\">ON_ERROR</code> if needed.</p>\n<p>In ABAP Abapittyy-bippy-boppy terms, that means adding the following code to our class. First in the <code class=\"language-text\">PUBLIC SECTION.</code>, these two lines to tell ABAP we are going to ‚Äòredefine‚Äô AKA <em>implement</em> those: </p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"></code></pre></div>\n<p>Then of course in the <code class=\"language-text\">CLASS ... IMPLEMENTATION.</code> section, the actual code for the two methods. For <code class=\"language-text\">ON_START</code>, it‚Äôs essential that we bind the push channel to that message channel we created. For this we need to pass both the message channel name as the <code class=\"language-text\">i_application_id</code> and the channel name as the <code class=\"language-text\">i_channel_id</code></p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"></code></pre></div>\n<p>For the <code class=\"language-text\">ON_MESSAGE</code> method - we need to do any work and formatting for the message we receive through the messaging channel. This is where things are a little backwards. You remember that message <em>channel</em> we built (not the push channel)? the one with channel name <code class=\"language-text\">/z_test</code>? Well, we would actually first need to know where messages are being emitted from. In this class, all we have available to use as to the content of the messages is via <code class=\"language-text\">i_message-&gt;get_text( )</code>. To keep the spirit of example going (since not everyone viewing this may have an EWM module and thus we can‚Äôt use the warehouse task example directly), I‚Äôm going to use the <code class=\"language-text\">SCUSTOM</code> table, a table of those fake flight which every ABAP developer knows well and cherishes lovingly <sup>right?</sup> <sup><sup>right?</sup></sup> </p>\n<p>Let‚Äôs assume that some business process on our server emits a customer ID that would correspond to a given entry in that <code class=\"language-text\">SCUSTOM</code> table.(we‚Äôll later make a quick script that does just that - obviously in a productive scenario it wouldn‚Äôt come from a random script but a business process). So in this case, via the <code class=\"language-text\">i_message-&gt;get_text( )</code> method, all we‚Äôll have is the customer‚Äôs ID. So we have to do a bit more work to get all the relavant information about the customer, as well as serizalizing it to JSON:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"></code></pre></div>\n<h2>I‚Äôve got the Push Channel, Now What‚Äôll I Do With It?!?</h2>\n<p>Now, as I mention before, we use the messaging channels to hook into any ABAP program, so that any time they are executed by anyone (or anything) in the system, the channel will be messaged. A safe way to hook into an existing program (using our newly created <code class=\"language-text\">Z_AWESOME_CHANNEL</code>) looks as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"><span class=\"token keyword\">REPORT</span> my_super_cool_existing_report\n<span class=\"token comment\">* lots of abap code here - actual program implemenetation</span></code></pre></div>\n<p>and since we‚Äôve already implemented our push channel, we should be all set to test a full stack case!</p>\n<h2>Quick Script To Emit Messages</h2>\n<p>Here‚Äôs a super simple script which will select a customer <code class=\"language-text\">ID</code> at random from the <code class=\"language-text\">SCUSTOM</code> table and emit it to our - go ahead and activate it and let it run. Remember - there is no harm in the system as our try catch statement will handle any cases when ABAP can‚Äôt find any active instances of our push channel.</p>\n<h2>Frontend</h2>\n<p>On the frontend I create a general websocket function that creates a websocket instance. In order to have the correct service for each view, upon each view change I call this function, which always creates a new instance if there exists a websocket instance already. This way we are sure that on any view change, we have a fresh running instance of the websocket doing the correct task for this view.</p>\n<p>That function looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"></code></pre></div>\n<p>Note that you of course have to use <code class=\"language-text\">ws://</code> as the protocol in the link name!</p>\n<p>On the backend, that ends up looking like a <code class=\"language-text\">CASE</code> statement:</p>\n<div class=\"gatsby-highlight\" data-language=\"abap\"><pre class=\"language-abap\"><code class=\"language-abap\"><span class=\"token keyword\">CASE</span></code></pre></div>\n<h2>Review - Websocket Advantages</h2>\n<p>In summary, what are the advantages we got by using a websocket?</p>\n<ol>\n<li>Reduced the load on the DB - in fact we totally removed the load on the DB, moving all channel publishing code to our custom class handling new warehouse tasks (which already existed for other reasons anyway)!</li>\n<li>Reduced the input traffic from the ABAP server - what was before be an array of multiple JSON objects, using the new websocket version we are always guaranteed a single JSON object from a given warehouse task.</li>\n<li>Improved the user experience greatly - now users really <em>do</em> see the warehouse tasks appearing in realtime - not in annoying 10 second interval packets.</li>\n</ol>\n<p>Finally, I want to be very clear - in no way should websockets replace <em>all</em> of you I/O in any given app - and indeed for many tasks, using a websocket would actually be detrimental. In the case of my intial app load and warehouse task listing, I actually load the most recently dispatched tasks. In this case it is exactly conceptually correct via a GET call. It‚Äôs only the <em>streaming</em> of <em>new</em> warehouse tasks where the websocket protocol is used.</p>\n<p>Whew - that was a fun one! Tune in for more blog posts AND video tutorials on ABAP, SAPUI5 / OpenUI5 in 2020. I‚Äôve got my own SAPUI5 Web IDE / ABAP Server / Cloud Connector stack now, so there‚Äôs nothing stopping me!</p>\n<p>Cheers! üç∫</p>\n<p>Chris</p>\n<hr/>\n<h1>Footnotes</h1>\n<div id=\"footnote-1\">\n1. Note that unfortunately the Cloud Connector SAP Web IDE does not yet support websockets, that is, without network wizardry. I haven't managed to get it to work. I've left long ago a message with the person who was the lead on Cloud Connector asking if websocket (`ws` protocol) would eventually be supported, but haven't heard anything.\n</div>","frontmatter":{"title":"Full ABAP Push and Message Channel Tutorial With Working Code Examples","date":"January 14, 2020","description":null}}},"pageContext":{"slug":"/draftposts/full-abap-push-and-message-channel-tutorial-with-working-code-examples/","previous":{"fields":{"slug":"/blog/goals-for-2020/"},"frontmatter":{"title":"Goals For 2020"}},"next":{"fields":{"slug":"/draftposts/one-major-challenge-with-the-internet-and-society/"},"frontmatter":{"title":"The Internet, Subscriptions, Big Winners, the Networking Effect, Makers & Creators, and Society Today"}}}}}